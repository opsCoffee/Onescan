## 执行模式：CI/CD 自动化（无人值守）

**环境**：GitHub Actions，无用户交互，所有操作自动批准（`--dangerously-skip-permissions`）。

**退出检查**：如果 `.agent/completed` 文件存在，立即退出（防止重复执行）。

## TODO list:

请以深度思考模式，调用子代理和mcp来完成如下任务：

请对当前项目代码库进行全面的技术审查，重点分析以下方面：

1. **逻辑错误**：
   - 识别所有可能导致程序行为异常的逻辑缺陷
   - 对每个问题提供具体的代码位置（文件路径和行号）
   - 解释错误的潜在影响和复现条件
   - 分析边界条件处理（空值、空集合、边界值）

2. **冗余代码**：
   - 查找重复实现的功能模块
   - 识别可以合并或抽象为公共函数的相似代码段
   - 标记未使用的变量、函数和导入
   - 检测可以用设计模式简化的重复逻辑

3. **数据流分析**：
   - 追踪关键数据在系统中的流转路径（从输入到输出）
   - 识别数据转换和处理的各个阶段
   - 检查数据验证和清洗的完整性
   - 发现潜在的数据泄漏或污染点
   - 分析数据依赖关系和耦合度

4. **算法复杂度评估**：
   - 分析核心算法的时间复杂度（Big O）
   - 评估空间复杂度和内存使用模式
   - 识别可优化的嵌套循环和递归调用
   - 检测潜在的性能退化场景（如 O(n²) 可优化为 O(n)）
   - 标记大数据量下可能的性能瓶颈

5. **并发安全审查**：
   - 检查共享资源的访问控制（线程安全）
   - 识别潜在的竞态条件和死锁风险
   - 评估同步机制的正确性和效率
   - 检查线程池和异步任务的资源管理
   - 分析并发场景下的数据一致性保障

6. **架构设计审查**：
   - 评估模块间的耦合度和内聚性
   - 检查是否遵循 SOLID 原则
   - 识别违反单一职责的"上帝类"
   - 分析依赖注入和控制反转的使用
   - 评估接口设计的合理性和扩展性

7. **内存安全与资源管理**（Linus 级别审查）：
   - **内存生命周期**：检查所有内存分配是否有对应的释放路径
   - **边界检查**：验证数组访问、缓冲区操作是否有越界保护
   - **空指针解引用**：识别所有可能的 NPE 风险点
   - **资源所有权**：明确每个资源的所有者和释放责任
   - **RAII 模式**：评估资源获取即初始化的使用情况
   - **引用计数**：检查对象生命周期管理的正确性

8. **错误处理与边界条件**（零容忍标准）：
   - **错误传播**：检查错误是否正确向上传播而非被吞没
   - **异常安全性**：评估异常发生时的资源清理和状态一致性
   - **防御性编程**：检查输入验证的完整性（永远不信任外部输入）
   - **失败路径测试**：标记缺少错误路径测试的关键代码
   - **错误日志**：评估错误信息的可调试性和完整性
   - **优雅降级**：检查系统在部分故障时的行为

9. **API 设计与接口契约**（可用性审查）：
   - **接口语义**：评估 API 命名和行为是否符合最小惊讶原则
   - **参数验证**：检查公共接口是否验证所有输入参数
   - **返回值语义**：明确成功/失败的返回值约定
   - **副作用文档化**：标记有隐藏副作用的函数
   - **向后兼容性**：评估 API 变更对现有调用者的影响
   - **接口最小化**：识别过度暴露内部实现的接口

10. **代码可读性与可维护性**（6个月后能看懂）：
    - **命名规范**：检查变量、函数、类名是否清晰表达意图
    - **函数长度**：标记超过 50 行的函数（应拆分）
    - **注释质量**：评估注释是否解释"为什么"而非"是什么"
    - **魔法数字**：识别所有未命名的常量
    - **代码自文档化**：检查代码结构是否足够清晰
    - **认知复杂度**：评估代码的理解难度（嵌套层级、分支数）

11. **安全漏洞审查**（安全第一）：
    - **注入攻击**：检查 SQL、命令、路径注入风险
    - **权限校验**：验证所有敏感操作的权限检查
    - **加密使用**：评估密码学算法的正确使用
    - **敏感数据**：检查密码、密钥等是否明文存储或日志
    - **时序攻击**：识别可能的时序侧信道泄漏
    - **整数溢出**：检查数值运算的溢出保护

12. **技术债务**：
    - 评估不符合项目代码规范的实现
    - 识别性能瓶颈和资源使用效率低下的区域
    - 发现缺乏适当错误处理的代码段
    - 标记测试覆盖率不足的关键功能
    - 检查资源泄漏（文件句柄、数据库连接、内存）

13. **过度设计与简洁性**（YAGNI 原则）：
    - **过度抽象**：识别不必要的抽象层和设计模式滥用
    - **未使用的功能**：标记实现了但从未被调用的代码
    - **过早优化**：发现在没有性能瓶颈时的复杂优化
    - **配置过度**：检查是否有过多的可配置项增加复杂度
    - **框架依赖**：评估是否引入了不必要的重量级框架
    - **简单方案**：为复杂实现提供更简单的替代方案

14. **用户体验与直觉性**（产品思维）：
    - **API 直觉性**：评估接口使用是否符合用户心智模型
    - **错误提示**：检查错误消息是否清晰、可操作、用户友好
    - **默认值合理性**：评估默认配置是否满足 80% 用例
    - **学习曲线**：识别需要大量文档才能理解的复杂设计
    - **一致性**：检查命名、行为、风格在整个项目中的一致性
    - **响应速度**：评估用户可感知的操作延迟（UI 响应、API 延迟）
    - **反馈机制**：检查长时间操作是否有进度提示

15. **最佳实践遵守**（行业标准）：
    - **语言惯用法**：检查是否遵循语言特定的最佳实践（Java/Go/Python 等）
    - **框架规范**：评估是否正确使用框架的推荐模式
    - **设计模式**：识别应该使用但未使用的经典模式
    - **代码风格**：检查是否符合团队/社区的代码风格指南
    - **依赖管理**：评估依赖版本、许可证、安全性
    - **文档标准**：检查 README、API 文档、注释的完整性
    - **测试策略**：评估单元测试、集成测试、E2E 测试的覆盖

16. **可观测性与调试性**（运维友好）：
    - **日志规范**：检查日志级别使用是否合理（DEBUG/INFO/WARN/ERROR）
    - **关键路径追踪**：评估是否可以追踪请求的完整生命周期
    - **性能指标**：检查是否暴露关键性能指标（延迟、吞吐量）
    - **健康检查**：评估服务健康检查的完整性
    - **调试信息**：检查生产环境问题的可调试性
    - **监控埋点**：识别缺少监控的关键业务逻辑

17. **修复方案**：
   - 为每个问题提供具体、可执行的修复建议
   - 按照优先级（高/中/低）对问题进行分类
   - 估计每个修复所需的工作量
   - 提供修复后的示例代码片段
   - 说明修复后的性能提升或风险降低程度

请以结构化报告的形式呈现分析结果，包含问题摘要、详细说明和修复建议三个部分。

---

## 报告输出规范

### 报告结构要求

报告必须保存为：`.agent/code_review_report.md`

报告必须包含以下固定结构：

```markdown
# 代码审查报告

**项目名称**：[项目名称]  
**审查日期**：[YYYY-MM-DD]  
**审查范围**：[描述审查的模块/文件范围]  
**审查人员**：AI Code Reviewer  

---

## 📊 执行摘要

### 总体评分
- **代码质量**：⭐⭐⭐⭐☆ (4/5)
- **安全性**：⭐⭐⭐☆☆ (3/5)
- **性能**：⭐⭐⭐⭐☆ (4/5)
- **可维护性**：⭐⭐⭐☆☆ (3/5)

### 问题统计
| 优先级 | 数量 | 占比 |
|--------|------|------|
| 🔴 高  | X    | XX%  |
| 🟡 中  | X    | XX%  |
| 🟢 低  | X    | XX%  |
| **总计** | **X** | **100%** |

### 关键发现
- [简要列出 3-5 个最重要的发现]

---

## 🔍 详细问题清单

### 1. [问题类别] - [问题标题]

**优先级**：🔴 高 / 🟡 中 / 🟢 低  
**影响范围**：[性能/安全/可维护性/用户体验]  
**发现维度**：[对应 17 个审查维度中的哪一个]

#### 问题描述
[清晰描述问题是什么，为什么是问题]

#### 问题位置
```
文件：src/main/java/com/example/Example.java
行号：L123-L145
函数：processData()
```

#### 代码示例
```java
// 当前实现（有问题的代码）
public void processData(List<String> data) {
    for (int i = 0; i < data.size(); i++) {
        for (int j = 0; j < data.size(); j++) {
            // O(n²) 复杂度
        }
    }
}
```

#### 影响分析
- **性能影响**：数据量 > 1000 时响应时间超过 5 秒
- **安全风险**：可能导致 DoS 攻击
- **用户体验**：界面卡顿，用户体验差

#### 修复建议
**方案 1：使用 HashSet 优化（推荐）**
```java
// 优化后的实现 - O(n)
public void processData(List<String> data) {
    Set<String> dataSet = new HashSet<>(data);
    for (String item : data) {
        if (dataSet.contains(item)) {
            // O(1) 查找
        }
    }
}
```

**预期效果**：
- 时间复杂度：O(n²) → O(n)
- 性能提升：1000 条数据从 5s → 50ms（100倍提升）
- 工作量估计：2 小时

**方案 2：使用并行流（备选）**
[如果有多个方案，列出备选方案]

---

### 2. [下一个问题...]

[重复上述结构]

---

## 📈 数据流分析

### 关键数据流图
```mermaid
graph LR
    A[用户输入] --> B[参数验证]
    B --> C[业务处理]
    C --> D[数据持久化]
    D --> E[响应返回]
    
    style B fill:#f9f,stroke:#333
    style D fill:#bbf,stroke:#333
```

### 数据流问题汇总
1. **验证缺失**：[位置] 缺少输入验证
2. **数据泄漏**：[位置] 敏感数据未脱敏
3. **转换错误**：[位置] 数据类型转换可能失败

---

## 🏗️ 架构问题

### 模块耦合度分析
```
高耦合模块：
- ModuleA ←→ ModuleB (双向依赖，需解耦)
- ServiceX → 15 个依赖项 (上帝类，需拆分)
```

### SOLID 原则违反
1. **单一职责违反**：`UserService` 同时处理认证、授权、用户管理
2. **开闭原则违反**：添加新支付方式需修改 `PaymentProcessor`

---

## 🔒 安全问题汇总

| 问题类型 | 位置 | 风险等级 | 修复状态 |
|----------|------|----------|----------|
| SQL 注入 | UserDao.java:L45 | 🔴 高 | 待修复 |
| XSS 漏洞 | CommentController.java:L78 | 🟡 中 | 待修复 |
| 硬编码密钥 | Config.java:L12 | 🔴 高 | 待修复 |

---

## ✅ 修复优先级路线图

### Phase 1：紧急修复（1-3 天）
- [ ] 🔴 修复 SQL 注入漏洞
- [ ] 🔴 移除硬编码密钥
- [ ] 🔴 修复内存泄漏问题

### Phase 2：重要优化（1-2 周）
- [ ] 🟡 优化 O(n²) 算法
- [ ] 🟡 解耦 ModuleA 和 ModuleB
- [ ] 🟡 添加缺失的错误处理

### Phase 3：改进提升（1 个月）
- [ ] 🟢 重构上帝类
- [ ] 🟢 提升测试覆盖率
- [ ] 🟢 改进代码可读性

---

## 📚 最佳实践建议

1. **代码规范**：建议引入 Checkstyle/SpotBugs 自动化检查
2. **测试策略**：关键业务逻辑测试覆盖率应达到 80%+
3. **文档完善**：API 接口缺少 Swagger 文档
4. **监控增强**：建议添加关键业务指标监控

---

## 📎 附录

### 审查工具
- 静态分析：SonarQube
- 依赖检查：OWASP Dependency-Check
- 性能分析：JProfiler

### 参考资料
- [Java 最佳实践](https://example.com)
- [安全编码规范](https://example.com)
```

### 报告风格要求

1. **使用 Emoji 图标**：增强可读性
   - 🔴 高优先级
   - 🟡 中优先级
   - 🟢 低优先级
   - ⭐ 评分
   - 📊 数据统计
   - 🔍 详细分析
   - 🏗️ 架构
   - 🔒 安全
   - ✅ 行动项

2. **使用表格**：结构化数据展示

3. **使用代码块**：所有代码必须有语法高亮

4. **使用 Mermaid 图**：复杂关系用图表展示

5. **使用对比格式**：修复前后代码对比

6. **量化指标**：所有性能改进必须有具体数字

**如果 TODO list 为空或选择暂停**：创建 `.agent/completed` 文件并退出。

## 执行规则:

### Workflow：
- 检查 `.agent/completed`，存在则退出
- TODO 为空：创建 `.agent/completed` 并退出
- TODO 非空：深度思考分析需求、设计数据结构、拆分任务
- 任务独立时并行执行，冲突时线性执行
- 每个任务完成后立即运行测试验证

### 工作规范：
- 使用 `.agent/` 存储计划和进度追踪
- 优先使用 mcp 和子代理处理独立任务
- 原子化变更，最小化修改范围
- 每个任务独立提交，便于问题定位和回滚
- CHANGELOG.md 遵循 Keep a Changelog 格式

### Git Commit 规范：
格式：`<type>(<scope>): <中文描述>`

类型：
- feat（新功能）
- fix（修复）
- docs（文档）
- refactor（重构）
- test（测试）
- chore（构建/工具）
- perf（性能优化）

**要求**：
- description 必须使用中文
- 禁止添加任何 AI 签名、footer 或 "Co-Authored-By"
- 描述要具体，说明改动内容和原因

示例：
- `refactor(logging): 合并emoji模块，减少文件碎片化`
- `chore(cleanup): 删除废弃的日志函数和未使用导入`
- `refactor(errors): 使用泛型trait消除错误处理函数重复`

### 测试验证：

#### 1. 基础编译与构建验证
每个任务完成后必须执行：

```bash
# 清理并编译（检查编译错误）
mvn clean compile

# 运行所有单元测试
mvn test

# 生成测试覆盖率报告
mvn test jacoco:report

# 完整构建（包含集成测试）
mvn clean package

# 检查测试覆盖率是否达标（目标：80%+）
mvn verify
```

#### 2. 代码质量检查

```bash
# 静态代码分析（SpotBugs + PMD）
mvn spotbugs:check pmd:check

# 代码风格检查
mvn checkstyle:check

# 依赖安全漏洞扫描
mvn dependency-check:check

# SonarQube 分析（如果配置）
mvn sonar:sonar
```

#### 3. 性能基准测试

```bash
# JMH 性能基准测试（如果有）
mvn clean install
java -jar target/benchmarks.jar

# 性能回归检查
# 确保关键方法的性能不低于基线
```

**性能验证标准**：
- 关键 API 响应时间 < 100ms (P95)
- 数据库查询时间 < 50ms (P95)
- 内存使用增长 < 10%
- CPU 使用率 < 70%

#### 4. 安全验证

```bash
# OWASP 依赖检查
mvn org.owasp:dependency-check-maven:check

# 查找硬编码密钥/密码
grep -r "password\|secret\|api_key" src/ --exclude-dir=test

# 检查敏感信息泄漏
git secrets --scan

# SQL 注入检查（使用 SQLMap 或类似工具）
# XSS 检查（使用 OWASP ZAP）
```

#### 5. 集成测试与端到端测试

```bash
# 启动测试环境
docker-compose -f docker-compose.test.yml up -d

# 运行集成测试
mvn verify -P integration-test

# 运行端到端测试
mvn verify -P e2e-test

# 清理测试环境
docker-compose -f docker-compose.test.yml down
```

#### 6. 回归测试

```bash
# 运行完整回归测试套件
mvn clean verify -P regression-test

# 检查是否有测试失败
# 检查是否有新的警告或错误
```

#### 7. 验证检查清单

每次修改后必须确认：

- [ ] ✅ 所有单元测试通过
- [ ] ✅ 测试覆盖率 ≥ 80%（关键模块 ≥ 90%）
- [ ] ✅ 无编译警告
- [ ] ✅ 无静态分析错误（SpotBugs/PMD）
- [ ] ✅ 代码风格检查通过（Checkstyle）
- [ ] ✅ 无安全漏洞（OWASP Dependency-Check）
- [ ] ✅ 性能无回归（关键指标不下降）
- [ ] ✅ 集成测试通过
- [ ] ✅ 文档已更新（如有 API 变更）
- [ ] ✅ CHANGELOG.md 已更新

#### 8. 测试失败处理流程

如果测试失败：

1. **记录失败信息**到 `.agent/test_failures.log`
   ```
   [时间戳] 测试失败
   文件：[修改的文件]
   测试：[失败的测试名称]
   错误：[错误信息]
   堆栈：[堆栈跟踪]
   ```

2. **分析失败原因**
   - 是新引入的 bug？
   - 是测试本身的问题？
   - 是环境问题？

3. **回滚或修复**
   ```bash
   # 如果是代码问题，回滚变更
   git reset --hard HEAD~1
   
   # 或者修复问题后重新测试
   mvn clean test
   ```

4. **记录到问题跟踪**
   - 更新 `.agent/errors.log`
   - 如果连续 3 次失败，停止执行并报告

#### 9. 性能监控

```bash
# 使用 JProfiler 或 VisualVM 进行性能分析
# 检查内存泄漏
jmap -dump:live,format=b,file=heap.bin [PID]

# 分析 GC 日志
java -Xlog:gc* -jar target/app.jar

# 火焰图生成（如果需要）
```

#### 10. 自动化测试报告

测试完成后生成报告：`.agent/test_report.md`

```markdown
# 测试报告

**测试时间**：[时间戳]
**提交哈希**：[Git commit hash]

## 测试结果摘要
- ✅ 单元测试：XX/XX 通过
- ✅ 集成测试：XX/XX 通过
- ✅ 覆盖率：XX%
- ✅ 性能测试：通过

## 详细结果
[详细测试结果]

## 问题列表
[如果有失败的测试]
```

### 完成后操作：
所有任务完成后：
1. 运行完整测试套件
2. 更新 `.agent/quality_improvement_summary.md` 添加本次执行结果
3. 执行 `git add . && git commit && git push`
4. 创建 `.agent/completed` 文件并退出

### 错误处理：
- 记录到 `.agent/errors.log`
- 如果测试失败，回滚变更并记录原因
- 继续下一任务，不要停止等待
- 如果连续3个任务失败，停止执行并报告

### 执行约束：
- 时间限制：6 小时
- 超时后提交已完成工作并退出
- 不要添加 TODO 外的任务
- 不要执行标记为"不执行"的高风险任务
