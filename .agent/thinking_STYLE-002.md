# STYLE-002: 减少嵌套深度 - 深度思考

## 任务背景

- **任务ID**: STYLE-002
- **问题**: doScan() 方法 5 层嵌套
- **原始位置**: BurpExtender.java:344-375
- **当前位置**: BurpExtender.java:400-483 (行号因 ARCH-001 重构改变)

## Linus 式五层思考

### 1. 数据结构分析
doScan() 的数据流:
- 输入: IHttpRequestResponse, from(来源), payloadItem(payload 类型)
- 核心数据: request/response, url, pathDict, payloads
- 数据流: 过滤 → 指纹识别 → 递归扫描(path × payload)

### 2. 特殊情况识别
当前代码分两部分:
1. **前置过滤**(401-429行):
   - 使用早返回(guard clauses)
   - 嵌套深度 1-2 层
   - ✅ 已经是"好品味"的代码

2. **递归扫描**(454-482行):
   - 双层 for 循环 + 多个 if 判断
   - 最大嵌套 3 层
   - ⚠️ 刚好在 Linus 的"3层红线"上

### 3. 复杂度审查
功能本质: **对 URL 路径的每一级 × 每个 payload 进行组合扫描**

当前方案的概念:
1. 路径层级遍历(for path)
2. payload 遍历(for item)
3. 线程池检查
4. HTTP payload 过滤
5. URL 路径构建(3种情况)
6. 任务提交

能否简化?
- 双层 for 是业务本质,无法消除
- 内部的 if 判断可以提取成方法

### 4. 破坏性分析
重构风险:
- ✅ doScan() 是 private 方法,不影响外部接口
- ✅ 提取的子方法设为 private,不破坏封装
- ✅ 不改变控制流,只是代码移动

向后兼容:
- ✅ 不改变方法签名
- ✅ 不改变业务逻辑
- ✅ 不影响现有调用者

### 5. 实用性验证
问题真实性:
- ✅ 双层 for 内部有 20 行逻辑,确实影响可读性
- ✅ URL 路径构建的逻辑有 3 个分支,理解成本高

解决方案复杂度:
- ✅ 提取方法是标准重构手法,不过度设计
- ✅ 不引入新的设计模式,保持简单

受益范围:
- ✅ 任何需要维护扫描逻辑的开发者
- ✅ 提升代码可测试性(提取的方法可独立测试)

## 最终决策

### 【核心判断】
✅ **值得做,但要温和**:
- 当前嵌套 3 层,在及格线上(不是垃圾代码)
- 双层 for 的内部逻辑可以提取,提升可读性
- 不需要大刀阔斧,只需要小幅优化

### 【重构方案】
1. **保持现有结构**,不拆 for 循环
2. **提取两个方法**:
   - `shouldSkipHttpPayload(path, item)` - 判断是否跳过 HTTP payload
   - `buildScanUrlPath(path, item, reqPath, reqHost)` - 构建扫描路径
3. **简化双层 for** 内的逻辑,让主路径更清晰

### 【预期效果】
- 嵌套深度不变(仍是 3 层,符合标准)
- 双层 for 内部逻辑从 20 行缩减到 5-6 行
- 每个提取的方法不超过 10 行
- 主路径更清晰,特殊情况被消除(提取到子方法)

## Linus 的评价

🟢 **好品味的重构**:
- 不是为了重构而重构
- 消除特殊情况,让主路径清晰
- 符合"一个函数做一件事"的原则
- 不引入不必要的抽象

## 执行计划

1. ✅ 读取 doScan() 代码
2. ✅ 分析嵌套结构
3. 🔄 提取 `shouldSkipHttpPayload()` 方法
4. 🔄 提取 `buildScanUrlPath()` 方法
5. 🔄 重构双层 for 循环
6. 🔄 验证编译和功能
7. 🔄 提交代码

## 风险控制

- 保持 doScan() 的接口不变
- 提取的方法设为 private
- 每次修改后运行构建,确保编译通过
- 不改变任何业务逻辑
